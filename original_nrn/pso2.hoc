track_data =0
xopen("parameterslist.hoc")
xopen("params.hoc")
xopen("model.hoc")
xopen("InOut.hoc")

MaxNP = 40
pop_size=300  		// size of the population.
TotalGenerations=2000
NUM_GENERATIONS=2000	



Best=1e150			// curent best individual
objref pop,res,sort_ind,temp_pop,temp_res,avg_par,std_par,temp_vec,best_indiv,p_file,g_file,score_file,PC
objref best_locs, velocities,temp_pvec,v_file,avg_file
LOAD_GENERATION=0       // if zero generates random initial population, if one load generation from file

//open main log file
g_file = new File()
if(LOAD_GENERATION==0){
  g_file.wopen("ga_log.txt")
}else{
  g_file.aopen("ga_log.txt")
}

p_file= new File()
score_file = new File()
v_file=new File()
avg_file = new File()
avg_file.wopen("track_things")

PC= new ParallelContext()

strdef brain,strmv

pop=new Matrix(pop_size,NP)
temp_pop=new Matrix(pop_size,NP)
best_locs=new Matrix(pop_size,NP)
velocities=new Matrix(pop_size,NP)
res=new Vector(pop_size,1e50)
temp_res=new Vector(pop_size,1e50)
sort_ind= new Vector(pop_size)
temp_vec=new Vector(pop_size)
temp_pvec=new Vector(NP)
avg_par=new Vector(NP)
std_par=new Vector(NP)
best_indiv=new Vector(NP)

num_gen=0
Tolorance=1e-4		//termination criterion (currently not implemented)

objref  r[MaxNP],transvec,rn
transvec = new Vector(MaxNP)
highindex = 2
lowindex = mcell_ran4_init(int(startsw()%999))

for (j=0;j<NP;j+=1){
	r[j] = new Random()
	r[j].MCellRan4(highindex+j*j)
	r[j].uniform(minvec.x[j],maxvec.x[j])
}
rn = new Random()
rn.MCellRan4(1)
rn.uniform(0,1) 

startsw()
xopen("Fit.hoc")	//Fit function

//=======================MAIN LOOP================================
proc GA(){local i,j,k,itteration

	init_pop()
	Param_dist()
	itteration=0
	while(num_gen<TotalGenerations && itteration<NUM_GENERATIONS){
        	GetBest()
               	PSO()
	//	Param_dist()
		print_things()
		Evaluate_pop()
		num_gen+=1
		itteration+=1
	}
 	print "-------------------------------final parameters----------------------------------"
	for (j=0;j<=NP-1;j+=1) printf("%10.5f ",pop.x[0][j])
	g_file.close()
}


proc PSO(){local i,j,sgn,vmax,tempv

	c1 = 2.5 
	c2 = 2.5
	chi = 0.7
	tempv=0

	for(j=0; j<pop_size;j+=1){
		for(i=0;i<NP;i+=1){
        		c1 = 1.2
		        c2 = 1.5
        		chi = 0.7
			if (rn.repick()<=0.02){
				c1*=rn.repick()
				c2*=rn.repick()
			}
			
			tempv=velocities.x[j][i]
			velocities.x[j][i]=chi*tempv+c1*(best_locs.x[j][i]-pop.x[j][i])+c2*(best_indiv.x[i]-pop.x[j][i])
			if(velocities.x[j][i]!=0){
				tempv=velocities.x[j][i]
				vmax=abs(maxvec.x[i]-minvec.x[i])
				velocities.x[j][i]=tempv%vmax+minvec.x[i]
				velocities.x[j][i]*=0.8
			}

			pop.x(j,i)+=velocities.x(j,i)
                        if(pop.x[j][i]>maxvec.x[i] || pop.x[j][i]<minvec.x[i]) {
                                tempv=pop.x[j][i]
                                vmax=(maxvec.x[i]-minvec.x[i])
                                pop.x[j][i]=tempv%vmax+minvec.x[i]
			}
		}
	}
}


//---------------------------------initial random population-----------------	
proc init_pop(){local i,j,tmp_pop_size,tmp_np

	if(LOAD_GENERATION==0){
		for (i=0;i<=pop_size-1;i+=1){
			for (j=0;j<=NP-1;j+=1){
				pop.x[i][j]=r[j].repick()
				velocities.x[i][j]=r[j].repick()
			}
		}
	best_locs=pop.c
	} else {
		p_file.ropen("curr_population")
		pop.scanf(p_file)
		p_file.close()
                if(LOAD_GENERATION==1){
		    ropen("curr_population_num")
	            num_gen=fscan()		
 		}	
	        print "num gen = " , num_gen	
                p_file.close()
	}
	Evaluate_pop()
}

//---------------------------------reset population save for best one-----------------	
proc reset_pop(){local i,j,temp2
	for (i=1;i<=pop_size-1;i+=1){
		for (j=0;j<=NP-1;j+=1){
                       	 pop.x[i][j]=abs(r[j].repick())
		}
	}
}

//----------------sorting of population 
proc GetBest(){local A,B,i,j,dumm

	sort_ind=res.sortindex
	for (i=0;i<=pop_size-1;i+=1){
	        if(res.x[i]<Best){
        	        best_indiv=pop.getrow(i)
                	Best=res.x[i]
        	}
	}

	//dumping best individual and entire population to files 
	p_file.wopen("best.params")
        best_indiv.printf(p_file,"%g \n")
        p_file.close()
	p_file.wopen("curr_population")
	pop.fprint(p_file,"%g\t","\n")
        p_file.close()
        p_file.wopen("curr_population_num")
	p_file.printf("%d\n",num_gen)
	p_file.close()	
	score_file.wopen("scores")
	res.printf(score_file,"%g \n")
	score_file.close()
	v_file.wopen("velocities")
	velocities.fprint(v_file,"%g\t","\n")
	v_file.close()
	p_file.wopen("local_bests")
        best_locs.fprint(p_file,"%g\t","\n")
        p_file.close()
}
//-------------evaluate each individual. modify to add parallel work
proc Evaluate_pop(){local i,j,count

	temp_chi=0
	for (i=0;i<=pop_size-1;i+=1){ 
		for(j=0;j<=NP-1;j+=1) transvec.x[j]=pop.x[i][j]
		brain="NULL"
 		PC.post("TASK",temp_chi,i,brain,transvec)
          	PC.submit("tfunk()\n")
	}
	count=0
	temp_loc=0
	while(PC.working()){
		PC.take("DONE",&temp_chi,&temp_loc,brain,transvec)
		if(temp_chi < res.x(temp_loc)){
			res.x[temp_loc] = temp_chi
			best_locs.setrow(temp_loc,pop.getrow(temp_loc))
 		}
	}
}
proc Evaluate_pop_sing(){local i,j,count

	temp_chi=0
	for (i=0;i<=pop_size-1;i+=1){ 
		for(j=0;j<=NP-1;j+=1) transvec.x[j]=pop.x[i][j]
		temp_chi=tfunk()
                if(temp_chi < res.x(temp_loc)){
                        res.x[temp_loc] = temp_chi
                        best_locs.setrow(temp_loc,pop.getrow(temp_loc))
                }
	}
}

//----------------------output function
proc print_things(){local j,avg,std

	printf("[Generation # %g]  ",num_gen)
        Etime=stopsw()/60
	g_file.printf("[Time = %10.1f min Generation =  %g] \t  ",Etime,num_gen)
	for (j=0;j<=NP-1;j+=1) {
		printf("%10.5f \t",best_indiv.x[j]) 
		g_file.printf("%10.5f \t",best_indiv.x[j])
	}
	printf("%15.7e\n",Best)
	g_file.printf("%15.7e\n",Best)
	g_file.flush()
	avg=res.mean(0,pop_size-1)
	std=res.var(0,pop_size-1)
	avg_file.printf("%10.5f \t %10.5f \n",avg,std)
	avg_file.flush()

	//pop.printf("%5.6f ")
}

//---------------Calculate mean and variance of population

proc Param_dist(){local i,j

        for (j=0;j<=NP-1;j+=1) {
                temp_vec=pop.getcol(j)
                avg_par.x[j]=temp_vec.mean(0,pop_size-1)
                std_par.x[j]=temp_vec.var(0,pop_size-1)
        }
}




PC.runworker()

GA()

PC.done()

